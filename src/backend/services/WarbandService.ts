import { Warband, ValidationResult, WarbandAbility } from '../models/types';
import { DataRepository } from './DataRepository';
import { CostEngine } from './CostEngine';
import { ValidationService } from './ValidationService';
import { NotFoundError } from '../errors/AppError';

/**
 * Warband Service
 * Orchestrates warband operations, coordinating between CostEngine, ValidationService, and DataRepository
 */
export class WarbandService {
  private repository: DataRepository;
  private costEngine: CostEngine;
  private validationService: ValidationService;

  constructor(repository: DataRepository) {
    this.repository = repository;
    this.costEngine = new CostEngine();
    this.validationService = new ValidationService();
  }

  /**
   * Creates a new warband with unique ID and initializes with zero cost.
   * The warband is automatically persisted to the repository.
   * 
   * @param data - Warband creation data including name, point limit, and ability
   * @param data.name - The name of the warband
   * @param data.pointLimit - The point limit (75 or 125)
   * @param data.ability - The warband ability (null if none)
   * @returns The created warband with generated ID and timestamps
   */
  createWarband(data: {
    name: string;
    pointLimit: 75 | 125;
    ability: WarbandAbility | null;
  }): Warband {
    const warband: Warband = {
      id: '', // Will be generated by repository
      name: data.name,
      ability: data.ability,
      pointLimit: data.pointLimit,
      totalCost: 0, // Initialize with zero cost
      weirdos: [],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Save to repository (generates ID and timestamps)
    return this.repository.saveWarband(warband);
  }

  /**
   * Retrieves a warband by ID from the repository.
   * 
   * @param id - The unique identifier of the warband
   * @returns The warband if found, null otherwise
   */
  getWarband(id: string): Warband | null {
    return this.repository.loadWarband(id);
  }

  /**
   * Returns all warbands from the repository.
   * 
   * @returns Array of all warbands (empty array if none exist)
   */
  getAllWarbands(): Warband[] {
    return this.repository.loadAllWarbands();
  }

  /**
   * Updates a warband with new data, recalculates all costs, and persists changes.
   * Uses centralized cost recalculation to ensure consistency.
   * 
   * @param id - The unique identifier of the warband to update
   * @param data - Partial warband data to merge with existing warband
   * @returns The updated warband with recalculated costs
   * @throws {NotFoundError} If warband with given ID does not exist
   */
  updateWarband(id: string, data: Partial<Warband>): Warband {
    // Load existing warband
    const existingWarband = this.repository.loadWarband(id);
    if (!existingWarband) {
      throw new NotFoundError('Warband', id);
    }

    // Merge updates
    const updatedWarband: Warband = {
      ...existingWarband,
      ...data,
      id: existingWarband.id, // Preserve ID
      createdAt: existingWarband.createdAt // Preserve creation date
    };

    // Use centralized cost recalculation
    const warbandWithCosts = this.recalculateAllCosts(updatedWarband);

    // Save to repository
    return this.repository.saveWarband(warbandWithCosts);
  }

  /**
   * Deletes a warband from the repository.
   * 
   * @param id - The unique identifier of the warband to delete
   * @returns True if warband was deleted, false if it didn't exist
   */
  deleteWarband(id: string): boolean {
    return this.repository.deleteWarband(id);
  }

  /**
   * Validates a warband against all game rules and constraints.
   * Delegates to ValidationService for comprehensive rule checking.
   * 
   * @param warband - The warband to validate
   * @returns Validation result with valid flag and array of errors
   */
  validateWarband(warband: Warband): ValidationResult {
    return this.validationService.validateWarband(warband);
  }

  /**
   * Recalculates all costs for a warband and its weirdos
   * Centralizes cost recalculation logic to ensure consistency
   * Requirements: 7.1, 7.2, 7.3, 7.4
   * 
   * @param warband - The warband to recalculate costs for
   * @returns The warband with updated costs
   */
  recalculateAllCosts(warband: Warband): Warband {
    // Recalculate costs for all weirdos
    const updatedWeirdos = warband.weirdos.map(weirdo => ({
      ...weirdo,
      totalCost: this.costEngine.calculateWeirdoCost(weirdo, warband.ability)
    }));

    // Recalculate warband total cost
    const totalCost = this.costEngine.calculateWarbandCost({
      ...warband,
      weirdos: updatedWeirdos
    });

    return {
      ...warband,
      weirdos: updatedWeirdos,
      totalCost
    };
  }
}
